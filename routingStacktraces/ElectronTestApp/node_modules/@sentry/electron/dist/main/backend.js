"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const electron_1 = require("electron");
const path_1 = require("path");
const core_1 = require("@sentry/core");
const node_1 = require("@sentry/node");
const shim_1 = require("@sentry/shim");
const utils_1 = require("@sentry/utils");
const common_1 = require("../common");
const sdk_1 = require("../sdk");
const normalize_1 = require("./normalize");
const uploader_1 = require("./uploader");
/** A promise that resolves when the app is ready. */
let appReady = Promise.resolve();
/** Gets the path to the Sentry cache directory. */
function getCachePath() {
    return path_1.join(electron_1.app.getPath('userData'), 'sentry');
}
/** Returns extra information from a renderer's web contents. */
function getRendererExtra(contents) {
    return {
        crashed_process: `renderer[${contents.id}]`,
        crashed_url: normalize_1.normalizeUrl(contents.getURL()),
    };
}
/** Backend implementation for Electron renderer backends. */
class MainBackend {
    /** Creates a new Electron backend instance. */
    constructor(frontend) {
        this.frontend = frontend;
        this.inner = new node_1.NodeBackend(frontend);
        const path = getCachePath();
        this.breadcrumbs = new utils_1.Store(path, 'breadcrumbs', []);
        this.context = new utils_1.Store(path, 'context', {});
    }
    /**
     * @inheritDoc
     */
    install() {
        let success = true;
        if (this.isNativeEnabled()) {
            success = this.installNativeHandler() && success;
        }
        if (this.isJavaScriptEnabled()) {
            success = this.installJavaScriptHandler() && success;
        }
        this.installIPC();
        this.installAutoBreadcrumbs();
        return success;
    }
    /**
     * @inheritDoc
     */
    eventFromException(exception) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.inner.eventFromException(exception);
        });
    }
    /**
     * @inheritDoc
     */
    eventFromMessage(message) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.inner.eventFromMessage(message);
        });
    }
    /**
     * @inheritDoc
     */
    sendEvent(event) {
        return __awaiter(this, void 0, void 0, function* () {
            yield appReady;
            return this.inner.sendEvent(event);
        });
    }
    /**
     * Uploads the given minidump and attaches event information.
     *
     * @param path A relative or absolute path to the minidump file.
     * @param event Optional event information to add to the minidump request.
     * @returns A promise that resolves to the status code of the request.
     */
    uploadMinidump(path, event = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.uploader) {
                return this.uploader.uploadMinidump({ path, event });
            }
            return 200;
        });
    }
    /** Returns the full list of breadcrumbs (or empty). */
    loadBreadcrumbs() {
        return this.breadcrumbs.get();
    }
    /**
     * @inheritDoc
     */
    storeBreadcrumb(breadcrumb) {
        // We replicate the behavior of the frontend
        const { maxBreadcrumbs = 30 } = this.frontend.getOptions();
        this.breadcrumbs.update(breadcrumbs => [...breadcrumbs, breadcrumb].slice(-Math.max(0, Math.min(maxBreadcrumbs, 100))));
        // Still, the frontend should merge breadcrumbs into events, for now
        return true;
    }
    /** Returns the latest context (or empty). */
    loadContext() {
        return this.context.get();
    }
    /**
     * @inheritDoc
     */
    storeContext(nextContext) {
        // We replicate the behavior of the frontend
        this.context.update(context => {
            if (nextContext.extra) {
                context.extra = Object.assign({}, context.extra, nextContext.extra);
            }
            if (nextContext.tags) {
                context.tags = Object.assign({}, context.tags, nextContext.tags);
            }
            if (nextContext.user) {
                context.user = Object.assign({}, context.user, nextContext.user);
            }
            return context;
        });
        // Still, the frontend should merge context into events, for now
        return true;
    }
    /** Returns whether JS is enabled. */
    isJavaScriptEnabled() {
        return this.frontend.getOptions().enableJavaScript !== false;
    }
    /** Returns whether native reports are enabled. */
    isNativeEnabled() {
        // Mac AppStore builds cannot run the crash reporter due to the sandboxing
        // requirements. In this case, we prevent enabling native crashes entirely.
        // https://electronjs.org/docs/tutorial/mac-app-store-submission-guide#limitations-of-mas-build
        if (process.mas) {
            return false;
        }
        return this.frontend.getOptions().enableNative !== false;
    }
    /** Activates the Electron CrashReporter. */
    installNativeHandler() {
        // We are only called by the frontend if the SDK is enabled and a valid DSN
        // has been configured. If no DSN is present, this indicates a programming
        // error.
        const dsn = this.frontend.getDSN();
        if (!dsn) {
            throw new core_1.SentryError('Invariant exception: install() must not be called when disabled');
        }
        // We will manually submit errors, but CrashReporter requires a submitURL in
        // some versions. Also, provide a productName and companyName, which we will
        // add manually to the event's context during submission.
        electron_1.crashReporter.start({
            companyName: '',
            ignoreSystemCrashHandler: true,
            productName: electron_1.app.getName(),
            submitURL: '',
            uploadToServer: false,
        });
        // The crashReporter has an undocumented method to retrieve the directory
        // it uses to store minidumps in. The structure in this directory depends
        // on the crash library being used (Crashpad or Breakpad).
        const reporter = electron_1.crashReporter;
        const crashesDirectory = reporter.getCrashesDirectory();
        this.uploader = new uploader_1.MinidumpUploader(dsn, crashesDirectory, getCachePath());
        // Flush already cached minidumps from the queue.
        utils_1.forget(this.uploader.flushQueue());
        // Start to submit recent minidump crashes. This will load breadcrumbs and
        // context information that was cached on disk prior to the crash.
        utils_1.forget(this.sendNativeCrashes({}));
        // Every time a subprocess or renderer crashes, start sending minidumps
        // right away.
        electron_1.app.on('web-contents-created', (_, contents) => {
            contents.on('crashed', () => __awaiter(this, void 0, void 0, function* () {
                try {
                    yield this.sendNativeCrashes(getRendererExtra(contents));
                }
                catch (e) {
                    console.error(e);
                }
                shim_1.addBreadcrumb({
                    category: 'exception',
                    level: shim_1.Severity.Critical,
                    message: 'Renderer Crashed',
                    timestamp: new Date().getTime() / 1000,
                });
            }));
        });
        if (this.frontend.getOptions().enableUnresponsive !== false) {
            electron_1.app.on('browser-window-created', (_, window) => {
                window.on('unresponsive', () => {
                    shim_1.captureMessage('BrowserWindow Unresponsive');
                });
            });
        }
        return true;
    }
    /** Activates the Node SDK for the main process. */
    installJavaScriptHandler() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.inner.install()) {
                return false;
            }
            // Override the transport mechanism with electron's net module
            this.inner.setTransport(electron_1.net);
            // This is only needed for the electron net module
            appReady = electron_1.app.isReady()
                ? Promise.resolve()
                : new Promise(resolve => {
                    electron_1.app.once('ready', resolve);
                });
            return true;
        });
    }
    /** Installs IPC handlers to receive events and metadata from renderers. */
    installIPC() {
        electron_1.ipcMain.on(common_1.IPC_PING, (event) => {
            event.sender.send(common_1.IPC_PING);
        });
        electron_1.ipcMain.on(common_1.IPC_CRUMB, (_, crumb) => {
            shim_1.addBreadcrumb(crumb);
        });
        electron_1.ipcMain.on(common_1.IPC_EVENT, (ipc, event) => {
            event.extra = Object.assign({}, getRendererExtra(ipc.sender), event.extra);
            shim_1.captureEvent(event);
        });
        electron_1.ipcMain.on(common_1.IPC_CONTEXT, (_, context) => {
            if (context.user) {
                shim_1.setUserContext(context.user);
            }
            if (context.tags) {
                shim_1.setTagsContext(context.tags);
            }
            if (context.extra) {
                shim_1.setExtraContext(context.extra);
            }
        });
    }
    /** Installs auto-breadcrumb handlers for certain Electron events. */
    installAutoBreadcrumbs() {
        this.instrumentBreadcrumbs('app', electron_1.app);
        electron_1.app.once('ready', () => {
            // We can't access these until 'ready'
            this.instrumentBreadcrumbs('Screen', electron_1.screen);
            this.instrumentBreadcrumbs('PowerMonitor', electron_1.powerMonitor);
        });
        electron_1.app.on('web-contents-created', (_, contents) => {
            // SetImmediate is required for contents.id to be correct
            // https://github.com/electron/electron/issues/12036
            setImmediate(() => {
                this.instrumentBreadcrumbs(`WebContents[${contents.id}]`, contents, [
                    'dom-ready',
                    'load-url',
                    'destroyed',
                ]);
            });
        });
    }
    /**
     * Hooks into the Electron EventEmitter to capture breadcrumbs for the
     * specified events.
     */
    instrumentBreadcrumbs(category, emitter, events = []) {
        const emit = emitter.emit.bind(emitter);
        emitter.emit = (event, ...args) => {
            if (events.length === 0 || events.indexOf(event) > -1) {
                const breadcrumb = {
                    category: 'electron',
                    message: `${category}.${event}`,
                    timestamp: new Date().getTime() / 1000,
                    type: 'ui',
                };
                shim_1.addBreadcrumb(breadcrumb);
            }
            return emit(event, ...args);
        };
    }
    /** Loads new native crashes from disk and sends them to Sentry. */
    sendNativeCrashes(extra) {
        return __awaiter(this, void 0, void 0, function* () {
            // Whenever we are called, assume that the crashes we are going to load down
            // below have occurred recently. This means, we can use the same event data
            // for all minidumps that we load now. There are two conditions:
            //
            //  1. The application crashed and we are just starting up. The stored
            //     breadcrumbs and context reflect the state during the application
            //     crash.
            //
            //  2. A renderer process crashed recently and we have just been notified
            //     about it. Just use the breadcrumbs and context information we have
            //     right now and hope that the delay was not too long.
            const uploader = this.uploader;
            if (uploader === undefined) {
                throw new core_1.SentryError('Invariant violation: Native crashes not enabled');
            }
            const event = { extra };
            const paths = yield uploader.getNewMinidumps();
            paths.map(path => {
                sdk_1.captureMinidump(path, event);
            });
        });
    }
}
exports.MainBackend = MainBackend;
//# sourceMappingURL=backend.js.map