{"version":3,"file":"dispatch.js","sourceRoot":"","sources":["../src/dispatch.ts"],"names":[],"mappings":";;;;;;;;;;AAIA;;;;;GAKG;AACH;IAIE;;;;;;;OAOG;IACH,YAAmB,OAAwB;QACzC,0EAA0E;QAC1E,2EAA2E;QAC3E,wEAAwE;QACxE,2EAA2E;QAC3E,0DAA0D;QAE1D,2EAA2E;QAC3E,0EAA0E;QAC1E,4EAA4E;QAC5E,cAAc;QAEd,+CAA+C;QAC/C,MAAM,aAAa,GACjB,OAAO,CAAC,IAAI,KAAK,SAAS;YACxB,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,YAAY;YACvC,CAAC,CAAC,OAAO,CAAC,YAAY,CAAC,CAAC,gBAAgB,CAAC;QAC7C,8CAA8C;QAE9C,IAAI,CAAC,KAAK,GAAG,IAAI,aAAa,CAAC,OAAO,CAAC,CAAC;IAC1C,CAAC;IAED;;OAEG;IACU,eAAe,CAC1B,IAAY,EACZ,KAAkB,EAClB,KAAY;;YAEZ,OAAO,IAAI,CAAC,KAAK,CAAC,eAAe,CAAC,IAAI,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC;QACxD,CAAC;KAAA;IAED;;OAEG;IACI,OAAO;QACZ,OAAO,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE,CAAC;IAC9B,CAAC;IAED;;OAEG;IACU,gBAAgB,CAC3B,SAAc,EACd,KAAyB;;YAEzB,OAAO,IAAI,CAAC,KAAK,CAAC,gBAAgB,CAAC,SAAS,EAAE,KAAK,CAAC,CAAC;QACvD,CAAC;KAAA;IAED;;OAEG;IACU,cAAc,CACzB,OAAe,EACf,KAAyB;;YAEzB,OAAO,IAAI,CAAC,KAAK,CAAC,cAAc,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;QACnD,CAAC;KAAA;IAED;;OAEG;IACU,YAAY,CACvB,KAAkB,EAClB,KAAyB;;YAEzB,OAAO,IAAI,CAAC,KAAK,CAAC,YAAY,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;QAC/C,CAAC;KAAA;IAED;;OAEG;IACI,aAAa,CAClB,UAAsB,EACtB,KAAyB;QAEzB,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC,UAAU,EAAE,KAAK,CAAC,CAAC;IAC9C,CAAC;IAED;;OAEG;IACI,MAAM;QACX,OAAO,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE,CAAC;IAC7B,CAAC;IAED;;OAEG;IACI,UAAU;QACf,OAAO,IAAI,CAAC,KAAK,CAAC,UAAU,EAAE,CAAC;IACjC,CAAC;IAED;;OAEG;IACI,UAAU,CAAC,OAAgB,EAAE,KAAY;QAC9C,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;IACxC,CAAC;IAED;;OAEG;IACI,eAAe;QACpB,OAAO,IAAI,CAAC,KAAK,CAAC,eAAe,EAAE,CAAC;IACtC,CAAC;CACF;AAvHD,4CAuHC","sourcesContent":["import { DSN, FrontendClass, Scope } from '@sentry/core';\nimport { Breadcrumb, Context, SentryEvent } from '@sentry/shim';\nimport { CommonFrontend, ElectronOptions } from './common';\n\n/**\n * The Sentry Electron SDK Frontend.\n *\n * @see ElectronOptions for documentation on configuration options.\n * @see SentryClient for usage documentation.\n */\nexport class ElectronFrontend implements CommonFrontend {\n  /** Actual frontend implementation for the main or renderer process. */\n  private readonly inner: CommonFrontend;\n\n  /**\n   * Creates a new Electron SDK instance.\n   *\n   * This constructor automatically chooses the right implementation for the\n   * process type (`browser` or `renderer`).\n   *\n   * @param options Configuration options for this SDK.\n   */\n  public constructor(options: ElectronOptions) {\n    // We dynamically load the frontend implementation for the current process\n    // type. In frontend bundlers such as webpack or rollup, those requires are\n    // resolved statically. For this reason, we use `module.require` for the\n    // main implementation here, which is only defined in the main process. The\n    // renderer implementation must use the default `require`.\n\n    // In case `process.type` is not defined, dispatch defaults to the renderer\n    // implementation, which should be fine for most cases. False positives of\n    // this would be running `@sentry/electron` in a bare node process, which is\n    // acceptable.\n\n    // tslint:disable:no-var-requires no-unsafe-any\n    const frontendClass: FrontendClass<CommonFrontend, ElectronOptions> =\n      process.type === 'browser'\n        ? module.require('./main').MainFrontend\n        : require('./renderer').RendererFrontend;\n    // tslint:enable:no-var-requires no-unsafe-any\n\n    this.inner = new frontendClass(options);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public async captureMinidump(\n    path: string,\n    event: SentryEvent,\n    scope: Scope,\n  ): Promise<void> {\n    return this.inner.captureMinidump(path, event, scope);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public install(): boolean {\n    return this.inner.install();\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public async captureException(\n    exception: any,\n    scope?: Scope | undefined,\n  ): Promise<void> {\n    return this.inner.captureException(exception, scope);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public async captureMessage(\n    message: string,\n    scope?: Scope | undefined,\n  ): Promise<void> {\n    return this.inner.captureMessage(message, scope);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public async captureEvent(\n    event: SentryEvent,\n    scope?: Scope | undefined,\n  ): Promise<void> {\n    return this.inner.captureEvent(event, scope);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public addBreadcrumb(\n    breadcrumb: Breadcrumb,\n    scope?: Scope | undefined,\n  ): void {\n    this.inner.addBreadcrumb(breadcrumb, scope);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public getDSN(): DSN | undefined {\n    return this.inner.getDSN();\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public getOptions(): ElectronOptions {\n    return this.inner.getOptions();\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setContext(context: Context, scope: Scope): void {\n    this.inner.setContext(context, scope);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public getInitialScope(): Scope {\n    return this.inner.getInitialScope();\n  }\n}\n"]}